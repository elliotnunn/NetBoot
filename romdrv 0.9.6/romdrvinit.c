#include <Files.h>#include <Types.h>#include <Events.h>#include <Memory.h>#include <Resources.h>#include <Errors.h>#include <Devices.h>#include <SetUpA4.h>#include <A4Stuff.h>/* Name of driver to load */#define kDrvrName "\p.Romdrv"#define UTableBase (*(DCtlHandle**) 0x11C)#define UnitNtryCnt (*(short*) 0x1D2)struct Driver {	short drvrFlags;	short drvrDelay;	short drvrEMask;	short drvrMenu;	short drvrOpen;	short drvrPrime;	short drvrCtl;	short drvrStatus;	short drvrClose;	Str255 drvrName;};short MyFindSpaceInUnitTable(void);OSErr MyOpenDriver(void);/* Stolen nearly verbatim from IM: Devices */short MyFindSpaceInUnitTable(void) {	Ptr  curUTableBase, newUTableBase;	short curUTableEntries, newUTableEntries;	short refNum, unitNum;	long *entryarray;		/* get current unit table values from low memory globals */	curUTableEntries = UnitNtryCnt;	curUTableBase = (Ptr)UTableBase;	entryarray = (long*)UTableBase;		/* search for empty space in the current unit table */	for(unitNum = curUTableEntries-1; unitNum >= 48; unitNum--) {		if(entryarray[unitNum] == 0) {			return unitNum;		}	}		/* no space in the current table, so make a new one */	/* increase the size of the table by 16 (an arbitrary value) */	newUTableEntries = curUTableEntries + 16;		/* allocate space for the new table */	newUTableBase = NewPtrSysClear((long)newUTableEntries * sizeof(Handle));	if(newUTableBase == nil) return dsMemFullErr;		/* copy the old table to the new table */	BlockMove(curUTableBase, newUTableBase, (long)curUTableEntries * sizeof(Handle));		/* set the new unit table values in low memory */	UTableBase = (void*)newUTableBase;	UnitNtryCnt = newUTableEntries;		unitNum = newUTableEntries - 1;	return unitNum;}/* Stolen from IM: Devices */OSErr MyOpenDriver(void){	Handle drvrHdl;	short drvrID;	short tempDrvrID;	ResType drvrType;	Str255 drvrName;	OSErr myErr = noErr;	struct IOParam pb;	char hackname[8];	struct Driver *drvrPtr;	DCtlHandle entryHdl;		hackname[0] = 7;	hackname[1] = '.';	hackname[2] = 'R';	hackname[3] = 'o';	hackname[4] = 'm';	hackname[5] = 'd';	hackname[6] = 'r';	hackname[7] = 'v';		tempDrvrID = MyFindSpaceInUnitTable();	if(tempDrvrID > 0) {		drvrHdl = GetResource((ResType)'DRVR', 192);		if(!drvrHdl) {			//DebugStr("\pCould not get named resource");			return openErr;		}				GetResInfo(drvrHdl, &drvrID, &drvrType, drvrName);		SetResInfo(drvrHdl, tempDrvrID, drvrName);				LoadResource(drvrHdl);		DetachResource(drvrHdl);				entryHdl = (DCtlHandle)NewHandleSysClear(40);		drvrPtr = *(struct Driver **)drvrHdl;		drvrPtr->drvrFlags |= dRAMBased | dCtlEnable | dNeedTime | dNeedLock | dReadEnable | dStatEnable;		drvrPtr->drvrDelay = 0x300;		(*entryHdl)->dCtlDriver = (Ptr)drvrHdl;		(*entryHdl)->dCtlFlags = drvrPtr->drvrFlags;		(*entryHdl)->dCtlDelay = drvrPtr->drvrDelay;		(*entryHdl)->dCtlEMask = drvrPtr->drvrEMask;		(*entryHdl)->dCtlMenu = drvrPtr->drvrMenu;		(*entryHdl)->dCtlPosition = 0;		(*entryHdl)->dCtlRefNum = ~tempDrvrID;		(*entryHdl)->dCtlWindow = NULL;				(*((DCtlHandle**)0x11C))[tempDrvrID] = entryHdl;				pb.ioCompletion = NULL;		pb.ioNamePtr = (StringPtr)hackname;		pb.ioPermssn = 0;		myErr = PBOpen((ParmBlkPtr)&pb, false);		if(myErr != noErr) {			//DebugStr("\pError with pbopen");		}		drvrHdl = GetResource((ResType)'DRVR', tempDrvrID);		SetResInfo(drvrHdl, drvrID, drvrName);						return(myErr);	} else {		return openErr;	}}int main(void) {	THz save, sys;			save = GetZone();	sys = SystemZone();	SetZone(sys);	if(MyOpenDriver() != 0) {		//DebugStr("\pProblem loading driver");	}	SetZone(save);}